---
title: BioDT Recreational Potential Model
subtitle: Technical Supplement
authors:
  - name: Joe Marsh Rossney
    affiliation: UK Centre for Ecology & Hydrology
  - name: Maddalena Tigli
    affiliation: UK Centre for Ecology & Hydrology
date: last-modified
date-format: long
abstract: >
  This supplement provides technical details about the BioDT Recreational Potential model (LINK TO SPECIFIC RELEASE).
---

## Introduction


## Mathematical description of the model

The RP model takes two inputs:

1. A persona
2. An area

and evaluates ...

While there have been several publications citing the RP model, none so far have included a mathematical description of the model itself.

In fact the mathematical basis of the RP model is extremely simple. Were it not for a area-dependent rescaling step (which arguably could be dropped) it would be nothing more than a linear combination (i.e. a weighted sum) at each 20 metre squared pixel.

Nevertheless, it is worth being fully explicit; by writing out the calculation in full, we can easily see where 



We begin by defining some short-hand notation.

Let $f : \mathbb{R}^2 \to \mathbb{R}$ be a scalar function whose domain can be interpreted as a two-dimensional spatial (e.g. lat-lon) domain, $x \in \mathbb{R}^2$. This is a mathematical representation of a single _raster_ layer. A multi-layer 'stack' of $n$ rasters can be denoted by a collection of layers enumerated by a subscript index, $\left( f_1(x), f_2(x), \ldots, f_n(x)\right)$.

### Domain-dependent rescalings

Let $f \vert_{\mathcal{X}}$ denote the restriction of $f$ to a domain $\mathcal{X} \subset \mathbb{R}^2$ which we will assume is simply connected, i.e. a single enclosed area with no holes. We now define a family of rescaled functions,

$$
\hat{f}(x \,; \mathcal{X}) := \frac{f(x) - \min f \big\vert_{\mathcal{X}}}{\max f \big\vert_{\mathcal{X}} - \min f \big\vert_{\mathcal{X}}} \, ,
$$

each of which corresponds to a particular choice of restriction, i.e. a particular area.

Assuming that $f(x)$ is not a constant function on $\mathcal{X}$, these rescaled functions are 'normalised' to the unit interval $[0, 1]$ within the domain $\mathcal{X}$, i.e. 

$$
\min_{x\in\mathcal{X}} \hat{f}(x \,; \mathcal{X}) = 0 \, , \qquad
\max_{x\in\mathcal{X}} \hat{f}(x \,; \mathcal{X}) = 1 \, .
$$

Of course, there is no guarantee on what values $\hat{f}(x \,; \mathcal{X})$ may take for values $x \notin \mathcal{X}$ outside of the area.

It is also important to be aware that, in general,

$$
\hat{f}(x \,; \mathcal{X}_1) \neq \hat{f}(x \,; \mathcal{X}_2) \, .
$$

That is, the RP value at any given pixel should be expected to change when a different area is selected, even if the persona and the input data stays the same.


### Basic layers

For the landscape and natural features components (i.e. $i = 1,2$) the feature rasters are precisely the binary presence/absence rasters discussed previously,

$$
f_{ij}(x) = I_{ij}(x) \, , \qquad i = 1, 2 \, .
$$


### Proximity contributions

For certain features like rivers and lakes it does not make sense to restrict their contributions to the Recreational Potential to the pixels in which they are present. One does not need to be standing in a lake to appreciate it!^[Indeed this is true for almost every type of feature, but these proximity contributions were only computed for roads/paths and water features.]

It makes sense to attempt to account for the presence of these features nearby. 

Let $\mathcal{Y}_{ij} \subset \mathbb{R}^2$ denote the set of coordinates in which the feature $(ij)$ is present, i.e.

$$
\mathcal{Y}_{ij} := \left\{ y \in \mathbb{R}^2 \mid \mathbb{I}_{ij}(y) \right\}
$$

First, each pixel is assigned a value that is the distance to the *nearest* feature.

$$
d_{ij}(x) = \min_{y\in \mathcal{Y}_{ij}} \lVert x - y \rVert_2
$$

where $\lVert x - y \rVert_2 = \sqrt{(x_1 - y_1)^2 + (x_2 - y_2)^2}$ is the usual Euclidean distance.

These distances must be mapped to the unit interval such that $0 \mapsto 1$ and $\infty \mapsto 0$, i.e. so that presence of the feature in this pixel results in the highest value of $1$, tailing off to $0$ when the feature is very far away.

There are many different ways to achieve this. For historical reasons (https://doi.org/10.1016/j.ecolind.2014.04.018) the function chosen is a smooth, monotonically decreasing function in the logistic family,

$$
f_{ij}(x) = \frac{\kappa + 1}{\kappa + \exp(\alpha \, d_{ij}(x))} \, , \qquad i=3,4 \, .
$$ 
{#eq-proximity}

It remains to specify values for the parameters $\kappa$ and $\alpha$, the latter of which is most important since it determines the rate at which the value of $f_{ij}$ declines as the distance to the nearest feature increases.

The parameters chosen in the original version of this code were^[The provenance of these values, which date back to the [earliest version of the code](https://github.com/BioDT/uc-ces/commit/5c5961376df6753725e634378fa709dac1050ff6), has been lost. Somewhat confusingly, earlier versions of the code also contained an explicit cutoff at $d=1500$, suggesting that the authors intended distances below this to result in meaningful contributions to the RP. In the author's opinion, there is no reason whatsoever to think that these values are particularly meaningful. The precision with which $\alpha$ is given is a particular curiosity.]

$$
\kappa = 6 \, , \qquad \alpha = 0.01011 \, ,
$$

resulting in a function that halves at approximately $d=175$ (metres) and drops to $0.1$ at approximately $d=375$. At this distance, features with a user-provided score of $10$ (i.e. the highest) would be equivalent to a local feature given a score of $1$ (the lowest). It is safe to assume that at distances greater than this the contribution from the feature would be indiscernible to the user.

(See plot here: https://github.com/BioDT/uc-ces-recreation/issues/19)


$$
f_{ij}(x) = u(d_{ij}(x) \,; \alpha, \kappa) \, , \qquad i = 3, 4 \, .
$$

### Calculation of a single component

Each component is calculated as a simple weighted sum of the features (items) contained within it,

$$
C_i(x \,; \{\rho_i\}) = \sum_{j=1}^{n_i} \rho_{ij} f_{ij}(x) \, .
$$

It is then rescaled within the chosen area according to the procedure above

$$
C_i(x \,; \rho_i) \longrightarrow \hat{C}_i(x \,; \{\rho_i\}, \mathcal{X})
$$

The four rescaled components are then added

$$
\mathrm{RP}(x \,; \rho_i, \mathcal{X}) = \sum_{i=1}^4 \hat{C}_i(x \,; \rho_i , \mathcal{X})
$$

and once again rescaled (in the same area) to make the result fall in the interval $[0, 1]$.

$$
\mathrm{RP} \longrightarrow \widehat{\mathrm{RP}}
$$


## Overview of the code

### Repository contents

Output of the `tree` command:

```txt
├── CONTRIBUTING.md
├── DESCRIPTION
├── inst
│   ├── examples
│   │   ├── capture_messages.R
│   │   ├── compute_component.R
|   |   ...
│   │   └── save_persona.R
│   ├── extdata
│   │   ├── config
│   │   │   └── config.csv
│   │   ├── personas
│   │   │   └── presets.csv
│   │   ├── rasters
│   │   │   ├── Bush
│   │   │   │   ├── FIPS_I.tif
│   │   │   │   ├── FIPS_N.tif
│   │   │   │   ├── SLSRA.tif
│   │   │   │   └── Water.tif
│   │   │   └── Scotland
│   │   │       ├── FIPS_I.tif
│   │   │       ├── FIPS_N.tif
│   │   │       ├── SLSRA.tif
│   │   │       └── Water.tif
│   │   └── shapefiles
│   │       ├── Bush
│   │       │   ├── Bush.cpg
│   │       │   ├── Bush.dbf
│   │       │   ├── Bush.prj
│   │       │   ├── Bush.shp
│   │       │   └── Bush.shx
│   │       └── Scotland
│   │           ├── Scotland.cpg
│   │           ├── Scotland.dbf
│   │           ├── Scotland.prj
│   │           ├── Scotland.shp
│   │           └── Scotland.shx
│   └── scripts
│       ├── cli
│       │   ├── app.sif
│       │   ├── main.R
│       │   └── README.md
│       └── data_production
│           ├── app.sif
│           ├── main.R
│           └── README.md
├── LICENSE
├── LICENSE.md
├── man
│   ├── assert_to_bool.Rd
│   ├── assert_valid_bbox.Rd
│   ...
│   └── timed.Rd
├── NAMESPACE
├── R                     # <1>
│   ├── app_run.R         # <1>
│   ├── app_server.R      # <1>
│   ├── app_text.R        # <1>
│   ├── app_theme.R       # <1>
│   ├── app_ui.R          # <1>
│   ├── bbox.R            # <1>
│   ├── config.R          # <1>
│   ├── data_download.R   # <1>
│   ├── data_input.R      # <1>
│   ├── data_production.R # <1>
│   ├── example.R         # <1>
│   ├── legacy.R          # <1>
│   ├── persona.R         # <1>
│   ├── recreation.R      # <1>
│   └── utils.R           # <1>
├── README.md
├── renv.lock
├── scripts
│   ├── cli_test.sh
│   ├── dev.sh
│   ├── pre-commit.R
│   ├── README.md
│   └── run_app.sh
├── tests
│   └── testthat
│       └── test_io.R
└── vignettes
    ├── compute_potential.qmd
    ├── personas.qmd
    └── run_app.qmd
```

1. Source code for the package


### Production of input data

### Recreational Potential calculation

### Interactive app


## Rationale for code structure




### Factoring expensive computations out

As explained [in this comment](https://github.com/BioDT/uc-ces-recreation/pull/18#discussion_r1938481780), the result of this is that the dynamic part of the model (i.e. the part that gets updated based on user input) is nothing more than the weighted sum in Eq ==@equation==.

This is the number one reason for the dramatic improvement in the speed at which RP can be computed, and the ability to compute RP over much larger areas without exhausting the available memory ([#4](https://github.com/BioDT/uc-ces-recreation/issues/4)). These points are explained in more detail in @sec-whyfast.


## Computational efficiency

- Storage requirements
- Memory requirements
- Speed of calculation for dynamic part
- Parallelisability

### Speed and memory use {#sec-whyfast}

```R
compute_component <- function(component, persona, bbox, data_dir = NULL, skip_checks = FALSE) {
    if (is.null(data_dir)) {
        data_dir <- get_data_dir()
    }
    if (!skip_checks) {
        assert_valid_component(component)
        assert_valid_data_dir(data_dir)
        assert_valid_bbox(bbox)
    }
    raster <- load_raster(
        file.path(data_dir, paste0(component, ".tif")),
        bbox
    )
    scores <- persona[names(raster)]
    result <- terra::app(raster, function(features) {  # <1>
		sum(scores * features, na.rm = TRUE)           # <1>
    })                                                 # <1>
    return(result)
}
```
1. Compute a weighted sum

`terra::app` automatically parallelises this multiply-and-sum operation across the grid; each 'pixel' is computed in a separate thread.

Even better, when `terra::app` is applied to a simple operator such as `sum`, it actually calls a fast `C++` implementation rather than a pure `R` one (see the [terra documentation](https://rdrr.io/cran/terra/man/app.html)).

Memory use - terra only has to load one pixel at a time per parallel thread. This means at any given instance only $N_\text{threads} \times N_\text{layers}$ values need to be loaded in memory, irrespective of how many pixels there are in total.


#### Higher memory use in distance


## How to

:::{.callout-note}
##### Publishing to UKCEH's Posit Connect server

Probably the easiest way to publish to Posit Connect is to install the R package `rsconnect` and run the following commands from the root of the repository:

```R
rsconnect::addServer("https://connect-apps.ceh.ac.uk", name="connect-apps.ceh.ac.uk")
rsconnect::connectApiUser(server="connect-apps.ceh.ac.uk", account="<username>", apiKey="<api key>")
rsconnect::deployApp(appDir=".")
```

This will take a long time if you have a lot of data to upload - for me it took up to an hour to upload ~2 gigabytes of data.

You will want to add the directory `rsconnect/` to your `.gitignore` file.

See the [UKCEH Posit Connect documentation](https://connect-apps.ceh.ac.uk/__docs__/user/publishing-r/) for further guidance (requires an account with UKCEH Posit Connect).
:::


:::{.callout-tip}
##### Variable names in R

Unlike Python, R does not allow variable names to have leading underscores. That is, `x <- 10` is fine but `_x <- 10` is not.

In our case the use of leading underscores led to a very confusing error message ([#17](https://github.com/BioDT/uc-ces-recreation2/issues/17)).
:::
