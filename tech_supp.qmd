---
title: The BioDT Recreational Potential Model
subtitle: Technical Supplement
authors:
  - name: "Joe Marsh Rossney <a href='https://github.com/jmarshrossney' style='color: black'><i class='bi bi-github'></i></a>"
    affiliations: UK Centre for Ecology & Hydrology
    orcid: 0000-0002-8082-8566
  - name: "Maddalena Tigli <a href='https://github.com/madtig' style='color: black'><i class='bi bi-github'></i></a>"

date: last-modified
date-format: long
abstract: >
  This supplement provides technical details about the BioDT Recreational Potential model (LINK TO SPECIFIC RELEASE). This includes a mathematical description of the model, and aspects of the code.

code-annotations: hover
---

## Description of the model

While there have been several publications citing the RP model, none so far have included a mathematical description of the model itself.

In fact the mathematical basis of the RP model is extremely simple. Nevertheless, it is worth being fully explicit. 

<!-- Were it not for an area-dependent rescaling step it would be nothing more than a linear combination (i.e. a weighted sum) at each 20 metre squared pixel.-->

### Inputs

The RP model takes three inputs:

1. A 
2. A _persona_, i.e. a set of 87 numbers (0--10) corresponding to the 87 unique features present in the raster data.
3. A 'region of interest'

and evaluates ...

### Presence/absence rasters

We begin by defining some notation.

Let $I : \mathbb{R}^2 \to \{0, 1\}$ be a binary-valued function whose domain can be interpreted as a two-dimensional spatial (e.g. lat-lon) domain, $x \in \mathbb{R}^2$. This is a mathematical representation of a single raster layer in a '[one-hot](https://en.wikipedia.org/wiki/One-hot)' representation, where a value of $I(x) = 1$ indicates presence of a feature at the coordinate $x$, and $I(x) = 0$ indicates absence. 

The RP model currently includes 87 features/items grouped into four components. Each of these has its own presence/absence raster. We will therefore introduce two subscript indices and write each layer as $I_{ij}(x)$, where

- $i \in \{1, 2, 3, 4\}$ labels the component to which $I_{ij}$ belongs, and
- $j \in \{1, 2, \ldots, n_i\}$ labels the item/feature within that component, of which there are $n_i$.

For example, if we say that $i=4$ labels the 'water' component, and $j=1$ labels the 'pond' item, then $I_{41}(x)$ takes a value of $1$ whenever there is a pond at $x$, and a value of $0$ elsewhere.

Let us be explicit in labelling the components:

| $i$ | Component        | Short code |
| --- | ---------------- | ---------- |
| 1   | Landscape        | `SLSRA`    |
| 2   | Natural Features | `FIPS_N`   |
| 3   | Infrastructure   | `FIPS_I`   |
| 4   | Water            | `Water`    |

### Proximity contributions

For certain features like rivers and lakes it does not make sense to restrict their contributions to the Recreational Potential to the pixels in which they are present. One does not need to be standing in a lake to appreciate it!^[Indeed this is true for almost every type of feature, but these proximity contributions were only computed for roads/paths and water features.]

It makes sense to attempt to account for the presence of these features nearby. 

Let $\mathcal{P}_{ij} \subset \mathbb{R}^2$ denote the set of coordinates in which the feature $(ij)$ is present, i.e.

$$
\mathcal{P}_{ij} := \left\{ x' \in \mathbb{R}^2 \mid I_{ij}(x') = 1 \right\} \, .
$$ {#eq-presence}

We first compute a 'distance raster' in which each pixel is assigned a value that is the (Euclidean) distance to the *nearest* pixel in which the feature $(ij)$ is present,

$$
d_{ij}(x) = \min_{x'\in \mathcal{P}_{ij}} \lVert x - x' \rVert_2 \, ,
$$ {#eq-distance}

where $\lVert x - x' \rVert_2 = \sqrt{(x_1 - x'_1)^2 + (x_2 - x'_2)^2}$.

These distances must be mapped to the unit interval such that $0 \mapsto 1$ and $\infty \mapsto 0$, i.e. so that presence of the feature in this pixel results in the highest value of $1$, tailing off to $0$ when the feature is very far away.

There are many different ways to achieve this. Following @Paracchini2014 [p. 374 -- Eq. 1], the function chosen is a smooth, monotonically decreasing function in the logistic family,

$$
u(d_{ij}(x) \,; \alpha, \kappa) = \frac{\kappa + 1}{\kappa + \exp(\alpha \, d_{ij}(x))} \, .
$$  {#eq-proximity}

It remains to specify values for the parameters $\kappa$ and $\alpha$, the latter of which is most important since it determines the rate at which the value of $u$ declines as the distance to the nearest feature increases.

The parameters chosen in the original version of this code were^[The provenance of these values, which date back to the [earliest version of the code](https://github.com/BioDT/uc-ces/commit/5c5961376df6753725e634378fa709dac1050ff6), has been lost. Somewhat confusingly, earlier versions of the code also contained an explicit cutoff at $d=1500$, suggesting that the authors intended distances below this to result in meaningful contributions to the RP. In the author's opinion, there is no reason whatsoever to think that these values are particularly meaningful. The precision with which $\alpha$ is given is a particular curiosity.]

$$
\kappa = 6 \, , \qquad \alpha = 0.01011 \, ,
$$ {#eq-proxparams}

resulting in a function that halves at approximately $d=175$ (metres) and drops to $0.1$ at approximately $d=375$. At this distance, features with a user-provided score of $10$ (i.e. the highest) would be equivalent to a local feature given a score of $1$ (the lowest). It is safe to assume that at distances greater than this the contribution from the feature would be indiscernible to the user.

==See plot here: https://github.com/BioDT/uc-ces-recreation/issues/19 ==

### Calculation of a single component

As mentioned previously, there are 87 features in total, each of which corresponds to (a) persona score,

$$
\rho_{ij} \in \{0, 1, \ldots, 10\} \, ,
$$ {#eq-score}

and (b) a raster layer $f_{ij}(x)$. For the landscape and natural features components (i.e. $i = 1,2$) the feature rasters are precisely the binary presence/absence rasters discussed previously,

$$
f_{ij}(x) = I_{ij}(x) \, , \qquad i = 1, 2 \, .
$$ {#eq-raster12}

For the infrastructure and water components ($i=3, 4$) the features rasters contain the proximity contributions described above,


$$
f_{ij}(x) = u(d_{ij}(x) \,; \alpha, \kappa) \, , \qquad i = 3, 4 \, .
$$ {#eq-raster23}

Each component is calculated as a simple weighted sum of the features contained within it,

$$
F_i(x \,; \rho_i) = \sum_{j=1}^{n_i} \rho_{ij} f_{ij}(x) \, ,
$$ {#eq-component}

where we have permitted $\rho_i$ to denote the set of persona scores $\{\rho_{i1}, \rho_{i2}, \ldots, \rho_{i n_i} \}$ for the $i$-th component.

### Domain-dependent rescalings

Let $F \vert_{\mathcal{R}}$ denote the restriction of a function $F$ to a domain $\mathcal{R} \subset \mathbb{R}^2$ which defines the region in which we wish to compute Recreational Potential. We now define a family of rescaled functions,

$$
\hat{F}(x \,; \mathcal{R}) := \frac{F(x) - \min F \big\vert_{\mathcal{R}}}{\max F \big\vert_{\mathcal{R}} - \min F \big\vert_{\mathcal{R}}} \, ,
$$ {#eq-rescale}

each of which corresponds to a particular choice of restriction, i.e. a particular region of interest.

Assuming that $F(x)$ is not a constant function on $\mathcal{R}$, these rescaled functions are 'normalised' to the unit interval $[0, 1]$ *within* the region of interest, i.e. 

$$
\min_{x\in\mathcal{R}} \hat{F}(x \,; \mathcal{R}) = 0 \, , \qquad
\max_{x\in\mathcal{R}} \hat{F}(x \,; \mathcal{R}) = 1 \, .
$$ {#eq-minmax}

It is important to be aware that with this approach to rescaling introduces a dependence on the region of interest. That is, 

$$
\hat{F}(x \,; \mathcal{R}_1) \neq \hat{F}(x \,; \mathcal{R}_2) \, .
$$ {#eq-regiondependence}

Thus, the RP value at any given pixel should be expected to change when a different area is selected, even if the persona and the input data stays the same.

### Calculation of Recreational Potential


To compute the Recreational Potential value, the four rescaled components are summed,

$$
F_{\mathrm{RP}}(x \,; \rho, \mathcal{R}) = \sum_{i=1}^4 \hat{F}_i(x \,; \rho_i , \mathcal{R}) \, ,
$$ {#eq-rp}

and rescaled $F_{\text{RP}} \longrightarrow \hat{F}_\text{RP}$ using @eq-rescale once more (with the same $\mathcal{R}$) so that the result falls in the interval $[0, 1]$.


## Overview of the repository

The repository can be found at [github.com/BioDT/uc-ces-recreation](https://github.com/BioDT/uc-ces-recreation).

The repository is organised in the following way, as shown using the `tree` command:

```txt
├── CONTRIBUTING.md  # <1>
├── DESCRIPTION  # <2>
├── inst
│   ├── examples
│   │   ├── capture_messages.R # <3>
│   │   ├── compute_component.R
|   |   ...
│   │   └── save_persona.R  # <3>
│   ├── extdata
│   │   ├── config
│   │   │   └── config.csv  # <4>
│   │   ├── personas
│   │   │   └── presets.csv  # <5>
│   │   ├── rasters
│   │   │   ├── Bush
│   │   │   │   ├── FIPS_I.tif  # <6>
│   │   │   │   ├── FIPS_N.tif
│   │   │   │   ├── SLSRA.tif
│   │   │   │   └── Water.tif   # <6>
│   │   │   └── Scotland
│   │   │       ├── FIPS_I.tif  # <7>
│   │   │       ├── FIPS_N.tif
│   │   │       ├── SLSRA.tif
│   │   │       └── Water.tif   # <7>
│   │   └── shapefiles
│   │       ├── Bush
│   │       │   ├── Bush.cpg  # <8>
│   │       │   ├── Bush.dbf
│   │       │   ├── Bush.prj
│   │       │   ├── Bush.shp
│   │       │   └── Bush.shx  # <8>
│   │       └── Scotland
│   │           ├── Scotland.cpg  # <9>
│   │           ├── Scotland.dbf
│   │           ├── Scotland.prj
│   │           ├── Scotland.shp
│   │           └── Scotland.shx  # <9>
│   └── scripts
│       ├── cli
│       │   ├── app.sif  # <10>
│       │   ├── main.R  # <11>
│       │   └── README.md
│       └── data_production
│           ├── app.sif  # <12>
│           ├── main.R  # <13>
│           └── README.md
├── LICENSE  # <14>
├── LICENSE.md  # <14>
├── man
│   ├── assert_to_bool.Rd  # <15>
│   ├── assert_valid_bbox.Rd
│   ...
│   └── timed.Rd  # <15>
├── NAMESPACE  # <16>
├── R
│   ├── app_run.R         # <17>
│   ├── app_server.R
│   ├── app_text.R
│   ├── app_theme.R
│   ├── app_ui.R
│   ├── bbox.R
│   ├── config.R
│   ├── data_download.R
│   ├── data_input.R
│   ├── data_production.R
│   ├── example.R
│   ├── legacy.R
│   ├── persona.R
│   ├── recreation.R
│   └── utils.R           # <17>
├── README.md
├── renv.lock  # <18>
├── scripts
│   ├── cli_test.sh  # <19>
│   ├── dev.sh  # <20>
│   ├── pre-commit.R  # <21>
│   ├── README.md
│   └── run_app.sh  # <22>
├── tests
│   └── testthat
│       └── test_io.R  # <23>
└── vignettes
    ├── compute_potential.qmd  # <24>
    ├── personas.qmd
    └── run_app.qmd  # <24>
```

1. Instructions for potential contributors.
2. The standard [`DESCRIPTION` file](https://r-pkgs.org/description.html) for R packages, containing metadata about the package.
3. Simple examples using the package functions, which get included in the generated documentation.
4. Configuration file, mapping layer names to raster values (for the pre-processing step) and descriptions (used in the Shiny app).
5. File containing two 'preset' personas: the 'hard' and 'soft' recreationalists described in @Rolph2024.
6. Dataset covering a small area, for use in examples and vignettes.
7. Dataset for all of Scotland. This is not included in the package and is instead downloaded separately.
8. Shapefile and auxiliary data for the example dataset.
9. Shapefile and auxiliary data for the full Scotland-wide dataset.
10. Container definition file used to build a Singularity container for `cli/main.R`.
11. Command-line script for the model taking a persona and bounding box as input. This is expected to be called from the main BioDT app.
12. Container definition file used to build a Singularity container for `data_production/main.R`.
13. Script that executes all steps of the data pre-processing pipeline.
14. MIT licenses (`.md` for the repository, no extension for the package).
15. Compiled documentation for the package, generated using [roxygen2](https://roxygen2.r-lib.org/).
16. The standard [`NAMESPACE`](https://r-pkgs.org/namespace.html) file for R packages, containing a list of functions provided by the package.
17. Source code for the package.
18. [`renv`](https://rstudio.github.io/renv/) lockfile used (in theory) to install packages deterministically. Used when deploying app to Posit Connect.
19. Bash script that runs `Rscript inst/scripts/cli/main.R` with example data.
20. Bash script that runs `pre-commit` if available, or else `Rscript scripts/pre-commit.R`, as well as the tests.
21. R script that emulates the behaviour of `pre-commit` when run, in case the latter is not installed.
22. Bash script that loads the local version of the package and runs the Shiny app, for convenience during development.
23. A file containing [unit tests](https://testthat.r-lib.org/). Essentially tokenistic, but provides a template for more unit tests to be added in future.
24. Some bare-bones [vignettes](https://r-pkgs.org/vignettes.html) demonstrating simple use of the package.

:::{.callout-note}
#### A note on the `inst/` directory

Apparently it has become standard practice to use the `inst/` directory to distribute additional elements such as scripts and Shiny apps along with the package. This is the practice we have adopted here. There are really just two important things to know about the `inst/` directory:

First, that its contents are copied to the top-level of the package when the package is built. Hence, the top level of the built package will contain `examples/`, `extdata/` and `scripts/` (the directory containing shell scripts is not included in the package).

Hence, in order for file paths to work when the package is installed, one must omit `inst/` from the path. But this means the path will not work during development.

The way to regain consistency between the two situations (installed versus not installed) is to use[`system.file`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/system.file). There are several examples of this in the code, including the one below, where paths to files or directories under `inst/` needed to be constructed.

```R
get_preset_persona_file <- function() {
    system.file("extdata", "personas", "presets.csv",
        package = "biodt.recreation", mustWork = TRUE
    )
}
```
:::

## Production of input data

The data production, or raster pre-processing stage refers to the production of the rasters that are directly multiplied by the persona scores in the dynamic part of the model. That is, the output of this stage is four multi-layered rasters $(f_1, f_2, f_3, f_4)$ corresponding to the four components, where $f_i := (f_{i1}, f_{i2}, \ldots, f_{i n_i})$, whose individual layers $f_{ij}$ are defined by @eq-raster12 (for $i = 1, 2$) and @eq-raster23 (for $i=2,3$).

The process of producing these rasters is currently split into two distinct parts:

1. A manual part in which categorical rasters are constructed from raw downloaded datasets using QGIS
2. A scripted part in which these categorical rasters are converted into the form required by the model, using `R`.

The scripted part is executed by running `inst/scripts/data_production/main.R` (or the containerised version) with the manually-produced categorical rasters already present. This script essentially boils down to calling four functions which are found in `R/data_production.R`:

```R
reproject_all(indir = "Stage_0", outdir = "Stage_1")
one_hot_all(indir = "Stage_1", outdir = "Stage_2")
stack_all(indir = "Stage_2", outdir = "Stage_3")
compute_proximity_rasters(indir = "Stage_3", outdir = "Stage_4")
```


### Manual part

**Chris' work.**

### Quantising the slope raster

With one exception, every raster layer produced by the manual process is an integer-valued categorical raster. The single exception is a 'slope' raster containing the average absolute gradient $s(x)$ within each pixel.

We use `terra::classify` to quantise this continuous range into six categories according to their steepness,

$$
C_{\text{slope}}(x) = \begin{cases}
1 & &0 \leq s(x) < 1.72 \\
2 & &1.72 \leq s(x) < 2.86 \\
3 & &2.86 \leq s(x) < 5.71 \\
4 & &5.71 \leq s(x) < 11.31 \\
5 & &11.31 \leq s(x) < 16.7 \\
6 & &16.7 \leq s(x) \, .
\end{cases}
$$ {#eq-slopequant}

The origin of these intervals is another historical artefact for which we have precedent albeit not a deeper justification.

### Reprojection

The categorical rasters produced in the previous stage do not necessarily share the exact same coordinate grid. They can be coerced to share the same grid using `terra::project`.

We projected all rasters onto a reference raster with the following properties:

- **Coordinate reference system** (CRS): [EPSG:27700](https://epsg.io/27700) (British National Grid)
- **Resolution**: 20 metres x 20 metres
- **Extent**: $(x_\text{min}, x_\text{max}, y_\text{min}, y_\text{max}) = (-10000, 660000, 460000, 1220000)$.

We used the 'nearest' interpolation mode (`method="near"`) since the data is categorical. The resulting rasters therefore contain the same set of integer values.

### Conversion to one-hot representation

The next stage converts the categorical rasters ($C_i(x) \in \{0, 1, \ldots, n_i\}$ into a set of presence/absence rasters for each feature. These binary-valued rasters are referred to as the *one-hot* representation of the data.

Consider the following categorical raster,

$$
C_i = \begin{bmatrix}
\ddots \\
& 1 & 0 & 0 \\
& 2 & 1 & 0 \\
& 2 & 1 & 3 & \\
& & & & \ddots
\end{bmatrix} \, .
$$ {#eq-catraster}

The one-hot encoding of this raster is written

$$
C_i \overset{\text{one hot}}{\longrightarrow} ( I_{i0}, I_{i1}, I_{i2}, I_{i3}, \ldots) \, ,
$$ {#eq-catonehot}

where the binary-valued presence/absence rasters are, in this case,

$$
\begin{align}
I_{i0} &= \begin{bmatrix}
\ddots \\
& 0 & 1 & 1 \\
& 0 & 0 & 1 \\
& 0 & 0 & 0 & \\
& & & & \ddots
\end{bmatrix} \, , \quad
I_{i1} = \begin{bmatrix}
\ddots \\
& 1 & 0 & 0 \\
& 0 & 1 & 0 \\
& 0 & 1 & 0 & \\
& & & & \ddots
\end{bmatrix} \, , \\
I_{i2} &= \begin{bmatrix}
\ddots \\
& 0 & 0 & 0 \\
& 1 & 0 & 0 \\
& 1 & 0 & 0 & \\
& & & & \ddots
\end{bmatrix} \, , \quad
I_{i3} = \begin{bmatrix}
\ddots \\
& 0 & 0 & 0 \\
& 0 & 0 & 0 \\
& 0 & 0 & 1 & \\
& & & & \ddots
\end{bmatrix} \, .
\end{align}
$$ {#eq-onehot}

**TODO:** This has a number of advantages: (**Duplicated in dev report**)

- Avoids indexing step - just multiplication and addition
- By representing present/absent as 1/0, interpolations (e.g. due to a reprojection) can be meaningfully interpreted
- Reflects how we should conceptualise the recreation potential - nothing more complicated than a linear combination
- Allows for more efficient memory management - only needs to hold 2 layers in memory at any time (the accumulated sum + the next layer to be added to the sum)

The implementation of this step involves the use of `terra::lapp` to parallelise the calculation over the spatial domain. In practice we use `NA` instead of `0` to denote absence.

```R
one_hot_pixel <- function(x) {  # <1>
	out <- matrix(0, nrow = length(x), ncol = length(feature_mapping))
	for (i in seq_along(feature_mapping)) {
		out[, i] <- ifelse(x == as.numeric(feature_mapping[i]), 1, NA)
	}
	return(out)
}  # <1>

layer <- terra::lapp(  # <2>
	layer,  # <2>
	fun = one_hot_pixel,  # <2>
	filename = outfile,  # <3>
	overwrite = TRUE,
	wopt = list(
		names = names(feature_mapping),
		datatype = "INT1U"
	)  # <3>
)
```

1. Take a single pixel value (`x`) of a single-layered raster and return the one-hot representation at that point, i.e. a vector of `n_i` values of which up to one is `1` (present) and the remainder are `NA` (absent).
2. Apply this function in a vectorised fashion to every pixel of the input faster.
3. Write the outputs to `outfile` as they are computed, to reduce memory requirements.

### Stacking into component rasters

This stage is nothing more than combining many single-layered rasters files into a single multi-layered raster for each component. Roughly speaking, we do

```R
# Construct a list of rasters from each .tif file in `infiles`
rasters <- lapply(infiles, terra::rast)

# Construct a single multi-layered raster from this list
stacked <- terra::rast(rasters)

# Re-apply layer names
layer_names <- unlist(lapply(rasters, names))
names(stacked) <- layer_names

# Write the combined raster to disk
terra::writeRaster(stacked, outfile)
```

Note that `terra::rast(rasters)` does not preserve layer names when `rasters` is a list of rasters, hence the need for the two lines prior to `writeRaster`.

:::{.callout-warning}
#### A warning about layer names
It is *very* unfortunate that the names we have used for the layers follow the same format (`filename_i` for integers `i`) as the names that are automatically generated by `terra::rast`. Because of this, if these two lines that re-apply layer names are omitted, it is not obvious that anything is wrong; no error will be thrown and one can go onto compute RP values, since the names are as expected.

However, *the results will be wrong*, since `terra::rast` will apply _the right names in the wrong order_.

Future developers are strongly recommended to fix this problem by using different layer names ([#50](https://github.com/BioDT/uc-ces-recreation/issues/50)). See Issue [#49](https://github.com/BioDT/uc-ces-recreation/issues/49) for further details.
:::

### Proximity contributions

This stage applies @eq-distance and @eq-proximity to each layer of the Infrastructure and Water components.

In fact @eq-distance is the most challenging computation in the whole processing pipeline, due to the fact that its memory requirements scale poorly with the size of the input raster. 

Every single other processing step is entirely local; all of the information required to generate an output value for a pixel at coordinate $x$ is contained in the input pixels at coordinate $x$. This makes it trivial to process the data in chunks, and memory costs scale linearly with the area of the chunks.

In contrast, calculating distance to the nearest feature is strongly non-local; the output value at $x$ is a function of the full set of input values. Naively, the entire raster must be loaded to compute the output at a single location. 

<!-- It is unlikely that the underlying C++ implementation of `GDALComputeProximity`, which is called by `terra::distance`, actually loads the entire raster into memory immediately, but in practice we find that more memory is allocated than is available. -->

**To do: Madda's solution**


## Calculation of Recreational Potential

The dynamic part of the model, i.e. the part that gets updated based on user input, amounts to little more than computing the weighted sum in @eq-component to calculate each component and summing the components (@eq-rp), with a rescaling by @eq-rescale after each step. As a result, it is extremely fast.

To understand why it is so quick, we will briefly look at the code implementing @eq-component (`R/recreation.R`). The important parts are:

```R
raster <- load_raster(  # <1>
	file.path(data_dir, paste0(component, ".tif")),
	bbox
) # <1>

scores <- persona[names(raster)]  # <2>

result <- terra::app(raster, function(features) {  # <3>
	sum(scores * features, na.rm = TRUE)
}) # <3>
```
1. Lazily load the raster, cropping to a region given by `bbox`
2. Extract the scores for this component from the `persona` dataframe
3. Compute the weighted sum in @eq-component.

`terra::app` automatically parallelises this multiply-and-sum operation across the grid; each 'pixel' is computed in a separate thread. Even better, when `terra::app` is applied to a simple operator such as `sum`, it actually calls a fast `C++` implementation rather than a pure `R` one (see the [terra documentation](https://rdrr.io/cran/terra/man/app.html)).

This is also a very memory-light operation; `terra` only _has_ to load one pixel at a time per parallel thread. This means at any given instance only $N_\text{threads} \times N_\text{layers}$ values need to be loaded in memory, irrespective of how many pixels there are in total.

- **TODO:** Rescaling step?

## Shiny app

The Shiny app is split across several files, each containing the `app_` prefix:

- `app_ui.R` contains a function `make_ui` that returns the user interface (UI), i.e. the layout of the Shiny app, sliders, map, buttons etc.
- `app_server.R` contains a function `make_server` that returns the `server` function, which defines the dynamic parts of the app, such as loading/saving/editing personas and drawing a rectangle on the map.
- `app_theme.R` contains some custom UI elements such as the colour scheme and logo.
- `app_text.R` contains the extended text elements of the app, such as the user guide.
- `app_run.R` contains a convenience function `run_app` for running the app.

As things stand, personas are stored in `.csv` files on the server side. This means the app requires write access to the server's filesystem. This is convenient, since users do not have to upload their own persona files. However, it is not a scalable solution. Future work should take a different approach to handling user's personas, such as providing the option to link the app to Google sheets.

**To do:** I can't think of any more important details. Screenshots?







