---
title: BioDT Recreational Potential Model
subtitle: Technical Supplement
authors:
  - name: "Joe Marsh Rossney <a href='https://github.com/jmarshrossney' style='color: black'><i class='bi bi-github'></i></a>"
    affiliations: UK Centre for Ecology & Hydrology
    orcid: 0000-0002-8082-8566
  - name: "Maddalena Tigli <a href='https://github.com/madtig' style='color: black'><i class='bi bi-github'></i></a>"

date: last-modified
date-format: long
abstract: >
  This supplement provides technical details about the BioDT Recreational Potential model (LINK TO SPECIFIC RELEASE).

code-annotations: hover
---


## Description of the model

While there have been several publications citing the RP model, none so far have included a mathematical description of the model itself. In fact the mathematical basis of the RP model is extremely simple. Nevertheless, it is worth being fully explicit. 

<!-- Were it not for an area-dependent rescaling step it would be nothing more than a linear combination (i.e. a weighted sum) at each 20 metre squared pixel.-->


### Inputs

The RP model takes three inputs:

1. A 
2. A _persona_, i.e. a set of 87 numbers (0--10) corresponding to the 87 unique features present in the raster data.
3. A 'region of interest'

and evaluates ...

...

### Presence/absence rasters

We begin by defining some notation.

Let $I : \mathbb{R}^2 \to \{0, 1\}$ be a binary-valued function whose domain can be interpreted as a two-dimensional spatial (e.g. lat-lon) domain, $x \in \mathbb{R}^2$. This is a mathematical representation of a single raster layer in a '[one-hot](https://en.wikipedia.org/wiki/One-hot)' representation, where a value of $I(x) = 1$ indicates presence of a feature at the coordinate $x$, and $I(x) = 0$ indicates absence. 

The RP model currently includes 87 features/items grouped into four components. Each of these has its own presence/absence raster. We will therefore introduce two subscript indices and write each layer as $I_{ij}(x)$, where

- $i \in \{1, 2, 3, 4\}$ labels the component to which $I_{ij}$ belongs, and
- $j \in \{1, 2, \ldots, n_i\}$ labels the item/feature within that component, of which there are $n_i$.

For example, if we say that $i=4$ labels the 'water' component, and $j=1$ labels the 'pond' item, then $I_{41}(x)$ takes a value of $1$ whenever there is a pond at $x$, and a value of $0$ elsewhere.

Let us be explicit in labelling the components:

| $i$ | Component        | Short code |
| --- | ---------------- | ---------- |
| 1   | Landscape        | `SLSRA`    |
| 2   | Natural Features | `FIPS_N`   |
| 3   | Infrastructure   | `FIPS_I`   |
| 4   | Water            | `Water`    |

### Proximity contributions

For certain features like rivers and lakes it does not make sense to restrict their contributions to the Recreational Potential to the pixels in which they are present. One does not need to be standing in a lake to appreciate it!^[Indeed this is true for almost every type of feature, but these proximity contributions were only computed for roads/paths and water features.]

It makes sense to attempt to account for the presence of these features nearby. 

Let $\mathcal{P}_{ij} \subset \mathbb{R}^2$ denote the set of coordinates in which the feature $(ij)$ is present, i.e.

$$
\mathcal{P}_{ij} := \left\{ x' \in \mathbb{R}^2 \mid I_{ij}(x') = 1 \right\} \, .
$$ {#eq-presence}

We first compute a 'distance raster' in which each pixel is assigned a value that is the (Euclidean) distance to the *nearest* pixel in which the feature $(ij)$ is present,

$$
d_{ij}(x) = \min_{x'\in \mathcal{P}_{ij}} \lVert x - x' \rVert_2 \, ,
$$ {#eq-distance}

where $\lVert x - x' \rVert_2 = \sqrt{(x_1 - x'_1)^2 + (x_2 - x'_2)^2}$.

These distances must be mapped to the unit interval such that $0 \mapsto 1$ and $\infty \mapsto 0$, i.e. so that presence of the feature in this pixel results in the highest value of $1$, tailing off to $0$ when the feature is very far away.

There are many different ways to achieve this. Following @Paracchini2014 [p. 374 -- Eq. 1], the function chosen is a smooth, monotonically decreasing function in the logistic family,

$$
u(d_{ij}(x) \,; \alpha, \kappa) = \frac{\kappa + 1}{\kappa + \exp(\alpha \, d_{ij}(x))} \, .
$$  {#eq-proximity}

It remains to specify values for the parameters $\kappa$ and $\alpha$, the latter of which is most important since it determines the rate at which the value of $u$ declines as the distance to the nearest feature increases.

The parameters chosen in the original version of this code were^[The provenance of these values, which date back to the [earliest version of the code](https://github.com/BioDT/uc-ces/commit/5c5961376df6753725e634378fa709dac1050ff6), has been lost. Somewhat confusingly, earlier versions of the code also contained an explicit cutoff at $d=1500$, suggesting that the authors intended distances below this to result in meaningful contributions to the RP. In the author's opinion, there is no reason whatsoever to think that these values are particularly meaningful. The precision with which $\alpha$ is given is a particular curiosity.]

$$
\kappa = 6 \, , \qquad \alpha = 0.01011 \, ,
$$ {#eq-proxparams}

resulting in a function that halves at approximately $d=175$ (metres) and drops to $0.1$ at approximately $d=375$. At this distance, features with a user-provided score of $10$ (i.e. the highest) would be equivalent to a local feature given a score of $1$ (the lowest). It is safe to assume that at distances greater than this the contribution from the feature would be indiscernible to the user.

==See plot here: https://github.com/BioDT/uc-ces-recreation/issues/19 ==

### Calculation of a single component

As mentioned previously, there are 87 features in total, each of which corresponds to (a) persona score,

$$
\rho_{ij} \in \{0, 1, \ldots, 10\} \, ,
$$ {#eq-score}

and (b) a raster layer $f_{ij}(x)$. For the landscape and natural features components (i.e. $i = 1,2$) the feature rasters are precisely the binary presence/absence rasters discussed previously,

$$
f_{ij}(x) = I_{ij}(x) \, , \qquad i = 1, 2 \, .
$$ {#eq-raster12}

For the infrastructure and water components ($i=3, 4$) the features rasters contain the proximity contributions described above,


$$
f_{ij}(x) = u(d_{ij}(x) \,; \alpha, \kappa) \, , \qquad i = 3, 4 \, .
$$ {#eq-raster23}

Each component is calculated as a simple weighted sum of the features contained within it,

$$
F_i(x \,; \rho_i) = \sum_{j=1}^{n_i} \rho_{ij} f_{ij}(x) \, ,
$$ {#eq-component}

where we have permitted $\rho_i$ to denote the set of persona scores $\{\rho_{i1}, \rho_{i2}, \ldots, \rho_{i n_i} \}$ for the $i$-th component.

### Domain-dependent rescalings

Let $F \vert_{\mathcal{R}}$ denote the restriction of a function $F$ to a domain $\mathcal{R} \subset \mathbb{R}^2$ which defines the region in which we wish to compute Recreational Potential. We now define a family of rescaled functions,

$$
\hat{F}(x \,; \mathcal{R}) := \frac{F(x) - \min F \big\vert_{\mathcal{R}}}{\max F \big\vert_{\mathcal{R}} - \min F \big\vert_{\mathcal{R}}} \, ,
$$ {#eq-rescale}

each of which corresponds to a particular choice of restriction, i.e. a particular region of interest.

Assuming that $F(x)$ is not a constant function on $\mathcal{R}$, these rescaled functions are 'normalised' to the unit interval $[0, 1]$ *within* the region of interest, i.e. 

$$
\min_{x\in\mathcal{R}} \hat{F}(x \,; \mathcal{R}) = 0 \, , \qquad
\max_{x\in\mathcal{R}} \hat{F}(x \,; \mathcal{R}) = 1 \, .
$$ {#eq-minmax}

It is important to be aware that with this approach to rescaling introduces a dependence on the region of interest. That is, 

$$
\hat{F}(x \,; \mathcal{R}_1) \neq \hat{F}(x \,; \mathcal{R}_2) \, .
$$ {#eq-regiondependence}

Thus, the RP value at any given pixel should be expected to change when a different area is selected, even if the persona and the input data stays the same.

### Calculation of Recreational Potential


To compute the Recreational Potential value, the four rescaled components are summed,

$$
F_{\mathrm{RP}}(x \,; \rho, \mathcal{R}) = \sum_{i=1}^4 \hat{F}_i(x \,; \rho_i , \mathcal{R}) \, ,
$$ {#eq-rp}

and rescaled $F_{\text{RP}} \longrightarrow \hat{F}_\text{RP}$ using @eq-rescale once more (with the same $\mathcal{R}$) so that the result falls in the interval $[0, 1]$.


## Overview of the code

### Repository contents

The repository is organised in the following way, as shown using the `tree` command:

```txt
├── CONTRIBUTING.md  # <1>
├── DESCRIPTION  # <2>
├── inst
│   ├── examples
│   │   ├── capture_messages.R # <3>
│   │   ├── compute_component.R
|   |   ...
│   │   └── save_persona.R  # <3>
│   ├── extdata
│   │   ├── config
│   │   │   └── config.csv  # <4>
│   │   ├── personas
│   │   │   └── presets.csv  # <5>
│   │   ├── rasters
│   │   │   ├── Bush
│   │   │   │   ├── FIPS_I.tif  # <6>
│   │   │   │   ├── FIPS_N.tif
│   │   │   │   ├── SLSRA.tif
│   │   │   │   └── Water.tif   # <6>
│   │   │   └── Scotland
│   │   │       ├── FIPS_I.tif  # <7>
│   │   │       ├── FIPS_N.tif
│   │   │       ├── SLSRA.tif
│   │   │       └── Water.tif   # <7>
│   │   └── shapefiles
│   │       ├── Bush
│   │       │   ├── Bush.cpg  # <8>
│   │       │   ├── Bush.dbf
│   │       │   ├── Bush.prj
│   │       │   ├── Bush.shp
│   │       │   └── Bush.shx  # <8>
│   │       └── Scotland
│   │           ├── Scotland.cpg  # <9>
│   │           ├── Scotland.dbf
│   │           ├── Scotland.prj
│   │           ├── Scotland.shp
│   │           └── Scotland.shx  # <9>
│   └── scripts
│       ├── cli
│       │   ├── app.sif  # <10>
│       │   ├── main.R  # <11>
│       │   └── README.md
│       └── data_production
│           ├── app.sif  # <12>
│           ├── main.R  # <13>
│           └── README.md
├── LICENSE  # <14>
├── LICENSE.md  # <14>
├── man
│   ├── assert_to_bool.Rd  # <15>
│   ├── assert_valid_bbox.Rd
│   ...
│   └── timed.Rd  # <15>
├── NAMESPACE  # <16>
├── R
│   ├── app_run.R         # <17>
│   ├── app_server.R
│   ├── app_text.R
│   ├── app_theme.R
│   ├── app_ui.R
│   ├── bbox.R
│   ├── config.R
│   ├── data_download.R
│   ├── data_input.R
│   ├── data_production.R
│   ├── example.R
│   ├── legacy.R
│   ├── persona.R
│   ├── recreation.R
│   └── utils.R           # <17>
├── README.md
├── renv.lock  # <18>
├── scripts
│   ├── cli_test.sh  # <19>
│   ├── dev.sh  # <20>
│   ├── pre-commit.R  # <21>
│   ├── README.md
│   └── run_app.sh  # <22>
├── tests
│   └── testthat
│       └── test_io.R  # <23>
└── vignettes
    ├── compute_potential.qmd  # <24>
    ├── personas.qmd
    └── run_app.qmd  # <24>
```

1. Instructions for potential contributors.
2. The standard [`DESCRIPTION` file](https://r-pkgs.org/description.html) for R packages, containing metadata about the package.
3. Simple examples using the package functions, which get included in the generated documentation.
4. Configuration file, mapping layer names to raster values (for the pre-processing step) and descriptions (used in the Shiny app).
5. File containing two 'preset' personas: the 'hard' and 'soft' recreationalists described in @Rolph2024.
6. Dataset covering a small area, for use in examples and vignettes.
7. Dataset for all of Scotland. This is not included in the package and is instead downloaded separately.
8. Shapefile and auxiliary data for the example dataset.
9. Shapefile and auxiliary data for the full Scotland-wide dataset.
10. Container definition file used to build a Singularity container for `cli/main.R`.
11. Command-line script for the model taking a persona and bounding box as input. This is expected to be called from the main BioDT app.
12. Container definition file used to build a Singularity container for `data_production/main.R`.
13. Script that executes all steps of the data pre-processing pipeline.
14. MIT licenses (`.md` for the repository, no extension for the package).
15. Compiled documentation in Markdown format, generated using [roxygen2](https://roxygen2.r-lib.org/).
16. The standard [`NAMESPACE`](https://r-pkgs.org/namespace.html) file for R packages, containing a list of functions provided by the package.
17. Source code for the package.
18. [`renv`](https://rstudio.github.io/renv/) lockfile used (in theory) to install packages deterministically. Used when deploying app to Posit Connect.
19. Bash script that runs `Rscript inst/scripts/cli/main.R` with example data.
20. Bash script that runs `pre-commit` if available, or else `Rscript scripts/pre-commit.R`, as well as the tests.
21. R script that emulates the behaviour of `pre-commit` when run, in case the latter is not installed.
22. Bash script that loads the local version of the package and runs the Shiny app, for convenience during development.
23. A file containing [unit tests](https://testthat.r-lib.org/). Essentially tokenistic, but provides a template for more unit tests to be added in future.
24. Some bare-bones [vignettes](https://r-pkgs.org/vignettes.html) demonstrating simple use of the package.

:::{.callout-note}
#### A note on the `inst/` directory

Apparently it has become standard practice to use the `inst/` directory to distribute additional elements such as scripts and Shiny apps along with the package. This is the practice we have adopted here. There are really just two important things to know about the `inst/` directory:

First, that its contents are copied to the top-level of the package when the package is built. Hence, the top level of the built package will contain `examples/`, `extdata/` and `scripts/` (the directory containing shell scripts is not included in the package).

Hence, in order for file paths to work when the package is installed, one must omit `inst/` from the path. But this means the path will not work during development.

The way to regain consistency between the two situations (installed versus not installed) is to use[`system.file`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/system.file). There are several examples of this in the code, including the one below, where paths to files or directories under `inst/` needed to be constructed.

```R
get_preset_persona_file <- function() {
    system.file("extdata", "personas", "presets.csv",
        package = "biodt.recreation", mustWork = TRUE
    )
}
```
:::

### Production of input data

### Recreational Potential calculation

### Interactive app


## Rationale for code structure




### Factoring expensive computations out

As explained [in this comment](https://github.com/BioDT/uc-ces-recreation/pull/18#discussion_r1938481780), the result of this is that the dynamic part of the model (i.e. the part that gets updated based on user input) is nothing more than the weighted sum in Eq ==@equation==.

This is the number one reason for the dramatic improvement in the speed at which RP can be computed, and the ability to compute RP over much larger areas without exhausting the available memory ([#4](https://github.com/BioDT/uc-ces-recreation/issues/4)). These points are explained in more detail in @sec-whyfast.


## Computational efficiency

- Storage requirements
- Memory requirements
- Speed of calculation for dynamic part
- Parallelisability

### Speed and memory use {#sec-whyfast}

```R
compute_component <- function(component, persona, bbox, data_dir = NULL, skip_checks = FALSE) {
    if (is.null(data_dir)) {
        data_dir <- get_data_dir()
    }
    if (!skip_checks) {
        assert_valid_component(component)
        assert_valid_data_dir(data_dir)
        assert_valid_bbox(bbox)
    }
    raster <- load_raster(
        file.path(data_dir, paste0(component, ".tif")),
        bbox
    )
    scores <- persona[names(raster)]
    result <- terra::app(raster, function(features) {  # <1>
		sum(scores * features, na.rm = TRUE)           # <1>
    })                                                 # <1>
    return(result)
}
```
1. Compute a weighted sum

`terra::app` automatically parallelises this multiply-and-sum operation across the grid; each 'pixel' is computed in a separate thread.

Even better, when `terra::app` is applied to a simple operator such as `sum`, it actually calls a fast `C++` implementation rather than a pure `R` one (see the [terra documentation](https://rdrr.io/cran/terra/man/app.html)).

Memory use - terra only has to load one pixel at a time per parallel thread. This means at any given instance only $N_\text{threads} \times N_\text{layers}$ values need to be loaded in memory, irrespective of how many pixels there are in total.


#### Higher memory use in distance

